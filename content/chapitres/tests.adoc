[{invert}]
= Tests

== ü§î Pourquoi tester un logiciel ?

* link:http://istqbexamcertification.com/when-do-defects-in-software-testing-arise/[Les Humains font des erreurs] et link:https://en.wikipedia.org/wiki/Turing_test[√©crivent du code]
** Le code est donc sujet √† erreurs: *Cons√©quences?*

* Les tests :
** Aident √† prouver que le logiciel se comporte comme attendu a tout moment
** √âvitent l'introduction de r√©gressions

* √âcrire des tests est un acte pr√©ventif et non curatif

== Qu'est ce que le "test logiciel" ?

* Le test logiciel est une pratique suivant 2 piliers :
** Valider que le logiciel remplisse les r√¥les qui lui sont confi√©s
** Rechercher les *fautes* pour les corriger,
am√©liorant la qualit√© du syst√®me

== Tests Automatis√© ou Manuels ?

* Automatiser : *r√©p√©tition* et *reproductibilit√©*
* Test Manuel √† consid√©rer dans *peu de cas*, quand :
** Co√ªt de l'automatisation d√©passe sa valeur
** Automatisation impossible

== Comment tester le logiciel ?

* La question *primordiale* est:
"Que voulez-vous tester ?"

* En fonction de la r√©ponse, diff√©rent types de tests
peuvent √™tre utilis√©s (liste NON exhaustive) :
** Unit testing
** Integration testing
** Smoke testing
** Functional Testing
** Non-Regression testing
** Acceptance testing

== Test Unitaire

* Focalis√© sur le plus petit sous-syst√®me possible du SUT, en "bo√Æte blanche"
* Tests *ind√©pendants* les uns des autres
** Ordre d'ex√©cution non important
** Utilisation de "bouchons" ("Test Doubles" ou "Mocks") pour simuler le "reste" en bon fonctionnement

image::test-unit.png[caption="Unit tests", width=300]

== Test Unitaire : Pro / Cons

* ‚úÖ Super rapides (<1s) et l√©gers a executer
* ‚úÖ Pousse √† avoir un bon design de code
* ‚úÖ Efficaces pour tester des cas limites
* ‚ùå Peu r√©alistes

[%notitle]
== fail

video::ut-fail-1.mp4[width="600",options="autoplay,loop,nocontrols"]

[%notitle]
== fail2

video::ut-fail-2.mp4[width="600",options="autoplay,loop,nocontrols"]

[{invert}]
== !

Tester des composants ind√©pendamment ne prouve pas que le syst√®me fonctionne une fois int√©gr√©!

== Solution: Tests d'int√©gration

* Test validant qu‚Äôun assemblage d‚Äôunit√©s se comportent comme pr√©vu.
* Teste votre application au travers de toutes ses couches

image::test-integration.gif[caption="Integration test"]

== Exemple d'une "suite" de tests d'int√©gration

* D√©marrer et provisionner un environnement d‚Äôex√©cution (une DB, Elasticsearch, un autre service...)
* D√©marrer votre application
* Jouer un sc√©nario de test
* √âteindre et nettoyer son environnement d‚Äôex√©cution pour garantir l'isolation des tests

== !

Ce sont des tests plus lents et plus complexes que des tests unitaires.

== Smoke Testing

image::test-smoke.jpg[caption="Plumbing Smoke Test",width=200]

* But : *Fail Fast* en "bo√Æte blanche"
* Valide les fonctions "de base" du syst√®me
* On parle parfois de "Sanity Checking"

[quote, Anonymous Electrician]
__
If it smokes, it's bad
__

== Tests Fonctionnels

* V√©rifie que le logiciel se comporte comme pr√©vu par
*les personnes en charge de la fabrication*
* Pas de *biais* d'interpr√©tation
* Le SUT est en "bo√Æte noire"

== Tests de R√©gression

* V√©rifie que le SUT a un comportement stable dans le temps
* Focalisation sur bug qui ne doit pas revenir
* Le SUT est en "bo√Æte noire"

image::test-regression.png[caption="Regression Test", width=200]

[quote, Any developer]
__
Correcting a single bug may introduce several more.
__

== Tests d'Acceptation

* √âgalement connu sous l'acronyme "UAT" User Acceptance Testing
* V√©rifie que le logiciel se comporte comme attendu par *l'utilisateur*
* Biais de communication inclus
* Le SUT est en "bo√Æte noire"

image::test-acceptance.jpg[caption="Acceptance tests",width=300]

== Priorit√© des Tests

* Fonction des temps d'ex√©cutions, des co√ªts de corrections,
et des valeurs ajout√©es. *Contextuel*.

image::test-pyramid.png[caption="The testing Pyramid",width=600]

== Test Driven Development

* TDD: √âcrire les tests unitaires *avant* le code

image::tdd.png[caption="TDD",width=400]

== Checkpoint üéØ

On a vu :

* üîç Qu'il faut tester son code
* üåç Qu'il existe diff√©rents type de tests en fonction de ce que l'on veut tester
* üß© Les concepts des tests unitaires
* ‚ùå Les limites des tests unitaires
* üè≠ Les concepts des tests d'int√©gration
* ü§î Tester n'est pas facile mais tr√®s utile
